---
title: "Analysis of over 65s in South East England"
author: "Zella King"
date: "1/9/2018"
output: html_document
---

```{r global_options, include=FALSE}
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE, fig.path='Figs/')
#fig.path='Figs/' makes it so the figure files get placed in the Figs subdirectory
```

```{r setup, cache=TRUE, echo=FALSE, warning=FALSE, message=FALSE}
library(reshape2)
library(data.table)
library(dplyr)
library(ggplot2)
install.packages("tidyverse", repos = "http://cran.us.r-project.org")
library(tidyverse)
```

##About the data used in this report

The data shown here are taken from the Projecting Older People Population Information System (POPPI) database. Originally developed for the Department of Health, this system provides population data by age band, gender, ethnic group, and tenure, for English local authorities.

Calculations are applied to population figures to estimate projected numbers of older people by; those living alone, living in care home, provision of unpaid care, their ability to carry out domestic tasks and self care.

Prevalence rates from research have been used to estimate the numbers of people suffering from: limiting long term illness, depression, severe depression, dementia, heart attack, stroke, bronchitis, emphysema, falls, continence, visual impairment, hearing impairment, mobility, obesity, diabetes and learning disabilities including Down's syndrome and autistic spectrum disorders (ASD).

More information on POPPI can be found at: http://www.poppi.org.uk/

##How the data were accessed

Anyone with an academic affiliation can access the data. Using these credentials, data were downloaded for the South East of England, and all the authorities wihtin the South East. Some counties are still organisationally a single unit (e.g. Oxfordshire, Surrey) while others (e.g. Berkshire) have been divided into unitary authorities. The data were downloaded to obtain projections at the smallest level of analysis (thus the counties were broken down into districts). The following data were selected:

* South East and the local authorities with the South East   
* counties in the South East and their districts  


```{r, echo=FALSE, cache=TRUE}

#get names all downloaded files
filenames<-list.files(path="~/Google Drive/Datasets/POPPI downloads 180115", full.names = TRUE)

#read all downloaded files into two dataframes
popnext5<-data.frame()
popto2035<-data.frame()
for (i in 1:length(filenames)) {
        a<-read.csv(filenames[i],stringsAsFactors = FALSE, skip = 3)
        a<-head(a, -4) #remove last four rows 
        if(names(a[3])=="X2018") {
                popnext5<-rbind(popnext5,a)  
        }
        else {
                popto2035<-rbind(popto2035,a)
        }
        
}

colnames(popnext5)<-c("description","y2017","y2018","y2019","y2020","y2021")
colnames(popto2035)<-c("description","y2017","y2020","y2025","y2030","y2035")

#remove duplicated rows and merge the two datasets
popnext5<-popnext5[!duplicated(popnext5),]
popto2035<-popto2035[!duplicated(popto2035),]
pop<-merge(popnext5,popto2035,by = c("description","y2017","y2020"))
rm(popnext5); rm(popto2035)

#parse the description into separate fields
a<-strsplit(pop$description,":")
b<-matrix(data = unlist(a),ncol = 2, byrow = TRUE); rm(a)
b<-as.data.frame(b)

#make data table with desired fields
pop<-data.table(pop,district = b$V1,age=b$V2); rm(b)
pop<-pop[,y2017:age]

#remove commas in numeric fields
pop$y2017<-as.numeric(gsub(",", "", pop$y2017))
pop$y2018<-as.numeric(gsub(",", "", pop$y2018))
pop$y2019<-as.numeric(gsub(",", "", pop$y2019))
pop$y2020<-as.numeric(gsub(",", "", pop$y2020))
pop$y2021<-as.numeric(gsub(",", "", pop$y2021))
pop$y2025<-as.numeric(gsub(",", "", pop$y2025))
pop$y2030<-as.numeric(gsub(",", "", pop$y2030))
pop$y2035<-as.numeric(gsub(",", "", pop$y2035))

#calculate CAGR - note - hardcoding the year interval
pop$cagr2035<-(pop$y2035/pop$y2017)^(1/18)-1
pop$cagr2025<-(pop$y2025/pop$y2017)^(1/8)-1

#identify the county level categories
a<-strsplit(filenames,"15-01-18_")
b<-matrix(data = unlist(a),ncol = 2, byrow = TRUE)
c<-strsplit(b[,2],"_and")
d<-matrix(data = unlist(c),ncol = 2, byrow = TRUE)
county_names<-unique(d[,1])
county_names<-sub("_"," ", county_names)
pop<-pop[,county_level:=pop$district %in% county_names]
```
##Compound annual growth in population over 65

The chart below shows the compound annual growth rate (CAGR) between 2017 and 2035 of the total population over the age of 65 for all districts in the South East. Where data are available, it also shows the county level projections, and for the South East as a whole. 

```{r}
#make a version with only the total numbers
pop_onlytot<-pop[,temp:=grepl("Total",pop$age)]
pop_onlytot<-pop_onlytot[ temp==1]
pop_onlytot<-pop_onlytot[,y2017:county_level]
#pop_onlytot<-pop_onlytot[ district!="South East"] - keep South East in for now

# Create dataset for circular plot
pop_onlytot<-pop_onlytot[order(-cagr2025)] #order by relevant field - do this every time
plotdata=data.frame( 
        id<-seq(1,75),
        district<-pop_onlytot$district,
        Level<-factor(as.numeric(pop_onlytot$county_level),levels=c(1,0), labels = c("County or region","District")),
        cagr2025_orig<-pop_onlytot$cagr2025,      
        cagr2025<-pop_onlytot$cagr2025/max(pop_onlytot$cagr2025)*100)
colnames(plotdata)<-c("id","district","county_level","cagr2025_orig","cagr2025")

#create dataset for labels
label_data=plotdata[,1:2]
number_of_bar=nrow(label_data)
angle= 90 - 360 * (label_data$id-0.5) /number_of_bar    
label_data$hjust<-ifelse( angle < -90, 1, 0)
label_data$angle<-ifelse(angle < -90, angle+180, angle)

#add CAGR labels to the label data
label_data$district<-as.factor(paste(as.character(plotdata$district)," (",round(plotdata$cagr2025_orig*100,1),"%)",sep=""))

#plot 
p = ggplot(plotdata, aes(x=as.factor(id), y=cagr2025,fill=Level)) + geom_bar(stat="identity") + ylim(-100,200) + 
        theme_minimal() +
        theme(axis.text = element_blank(), axis.title = element_blank(), panel.grid = element_blank(), plot.margin = unit(rep(1,4), "cm")) +
        coord_polar(start = 0) +
        geom_text(data=label_data, aes(x=id, y=cagr2025+10, label=district, hjust=hjust), color="black", fontface="bold",alpha=0.6, size=2.5, angle= label_data$angle, inherit.aes = FALSE ) 
p+labs(title = "Projected CAGR of populuation over 65, 2017-2025")
```

This chart shows the same data but now projecting the compound annual growth rate (CAGR) between 2017 and 2035. The districts are shown in the same order as the previous plot. The variation between teh 

```{r}

# Create dataset for circular plot
pop_onlytot<-pop_onlytot[order(-cagr2035)] #order by relevant field - do this every time
plotdata=data.frame( 
        id<-seq(1,75),
        district<-pop_onlytot$district,
        Level<-factor(as.numeric(pop_onlytot$county_level),levels=c(1,0), labels = c("County or region","District")),
        cagr2035_orig<-pop_onlytot$cagr2035,      
        cagr2035<-pop_onlytot$cagr2035/max(pop_onlytot$cagr2035)*100)
colnames(plotdata)<-c("id","district","county_level","cagr2035_orig","cagr2035")

#add new CAGR labels to the label data
label_data$district<-as.factor(paste(as.character(plotdata$district)," (",round(plotdata$cagr2035_orig*100,1),"%)",sep=""))

p = ggplot(plotdata, aes(x=as.factor(id), y=cagr2035,fill=Level)) + geom_bar(stat="identity") + ylim(-100,200) + 
        theme_minimal() +
        theme(axis.text = element_blank(), axis.title = element_blank(), panel.grid = element_blank(), plot.margin = unit(rep(1,4), "cm")) +
        coord_polar(start = 0) +
        geom_text(data=label_data, aes(x=id, y=cagr2035+10, label=district, hjust=hjust), color="black", fontface="bold",alpha=0.6, size=2.5, angle= label_data$angle, inherit.aes = FALSE ) 
p+labs(title = "Projected CAGR of populuation over 65, 2017-2035")
```

This chart shows the number of adults over 65 projected to live in each district in 2021. 

```{r}
#take subset without county level data
pop_onlytot_nocounty<-copy(pop_onlytot)
pop_onlytot_nocounty<-pop_onlytot_nocounty[ county_level==0]

pop_onlytot_nocounty<-pop_onlytot_nocounty[order(-y2021)] #order by relevant field - do this every time
plotdata=data.frame( 
        id<-seq(1,nrow(pop_onlytot_nocounty)),
        district<-pop_onlytot_nocounty$district,
        y2021_orig<-pop_onlytot_nocounty$y2021,      
        y2021<-pop_onlytot_nocounty$y2021/max(pop_onlytot_nocounty$y2021)*100)
colnames(plotdata)<-c("id","district","y2021_orig","y2021")

#create dataset for labels
label_data=plotdata[,1:2]
number_of_bar=nrow(label_data)
angle= 90 - 360 * (label_data$id-0.5) /number_of_bar    
label_data$hjust<-ifelse( angle < -90, 1, 0)
label_data$angle<-ifelse(angle < -90, angle+180, angle)

#add new CAGR labels to the label data
label_data$district<-as.factor(paste(as.character(plotdata$district)," (",round(plotdata$y2021_orig/1000,0),"K)",sep=""))

p = ggplot(plotdata, aes(x=as.factor(id), y=y2021)) + geom_bar(stat="identity",fill=alpha("skyblue", 0.7)) + ylim(-100,200) + 
        theme_minimal() +
        theme(axis.text = element_blank(), axis.title = element_blank(), panel.grid = element_blank(), plot.margin = unit(rep(1,4), "cm")) +
        coord_polar(start = 0) +
        geom_text(data=label_data, aes(x=id, y=y2021+10, label=district, hjust=hjust), color="black", fontface="bold",alpha=0.6, size=2.5, angle= label_data$angle, inherit.aes = FALSE ) 
p+labs(title = "Projected population over 65 in 2021")
```



```{r}
#make long thin dataset - note this includes county level and a summary for the South East
poplong<-melt(pop, id.vars = c("district","age","county_level"), measure.vars = c("y2017","y2018","y2019","y2020","y2021","y2025","y2030","y2035"))
colnames(poplong)<-c("district","age","county_level","year","pop")
poplong$year<-as.numeric(gsub("y", "", poplong$year)) #remove y from col names to make plot easier

#make another version without totals for each age category or South East
poplong_notot<-poplong[,temp:=grepl("Total",poplong$age)]
poplong_notot<-poplong_notot[ temp!=1]
poplong_notot<-poplong_notot[,district:pop]
poplong_notot<-poplong_notot[ county_level!=1]
poplong_notot_next5<-poplong_notot[ year < 2025]
```

Plot showing growth rates for each local authority
```{r, echo=FALSE, cache=TRUE}
plot <- ggplot(poplong_notot_next5,aes(x=year,y=pop, colour = age))
plot + geom_line() + facet_wrap(~ district, dir="v")
```


